%% ========================================================================
%% 非球面工件位姿求解 - SIL算法稳定完整版
%% ========================================================================
clear; clc; close all;

%% 参数设置
R = 1000; K = -2; A4 = 0; A6 = 0;
aperture_size = 300;

% 真实姿态
alpha_true = 3;
beta_true = 1.5;
px_true = 10;
py_true = -8;
pz_true = 10;

sigma_noise = 0.01;  % mm

% 构建真实旋转矩阵
Rx_true = [1, 0, 0;
           0, cosd(alpha_true), -sind(alpha_true);
           0, sind(alpha_true), cosd(alpha_true)];
Ry_true = [cosd(beta_true), 0, sind(beta_true);
           0, 1, 0;
          -sind(beta_true), 0, cosd(beta_true)];
R_true = Ry_true * Rx_true;
p_true = [px_true; py_true; pz_true];

fprintf('========== 非球面位姿求解 - SIL算法稳定版 ==========\n\n');
fprintf('【参数设置】\n');
fprintf('  非球面: R=%d mm, K=%.1f\n', R, K);
fprintf('  真实姿态: α=%.1f°, β=%.1f°, p=[%.1f,%.1f,%.1f]mm\n', ...
    alpha_true, beta_true, px_true, py_true, pz_true);
fprintf('  测量噪声: σ=%.2f mm\n\n', sigma_noise);

%% ========================================================================
%% 1. 生成测量数据
%% ========================================================================
fprintf('【生成测量数据】\n');

sample_xy = [0, 0];  % 中心点

% 1/3圆环 - 8个点
radius_1 = aperture_size/2 * (1/3);
angles_1 = linspace(0, 2*pi, 9);
for theta = angles_1(1:end-1)
    sample_xy = [sample_xy; radius_1*cos(theta), radius_1*sin(theta)];
end

% 2/3圆环 - 8个点
radius_2 = aperture_size/2 * (2/3);
angles_2 = linspace(0, 2*pi, 9);
for theta = angles_2(1:end-1)
    sample_xy = [sample_xy; radius_2*cos(theta), radius_2*sin(theta)];
end

N_points = size(sample_xy, 1);

P_measured = zeros(N_points, 3);
for i = 1:N_points
    x_W = sample_xy(i, 1);
    y_W = sample_xy(i, 2);
    z_W = compute_measured_z_correct(x_W, y_W, R_true, p_true, R, K, A4, A6);
    P_measured(i, :) = [x_W, y_W, z_W];
end

% 添加噪声
P_measured(:,3) = P_measured(:,3) + sigma_noise * randn(N_points, 1);

fprintf('  采样点数: N=%d\n', N_points);
fprintf('  完成\n\n');

%% ========================================================================
%% 2. SIL算法求解
%% ========================================================================
fprintf('========== SIL算法求解（解析导数） ==========\n');

% 初值设置
pz_init = mean(P_measured(:,3));  % 用测量点平均高度作为初值
lambda_0 = [0; 0; 0; 0; pz_init];

% 信赖域参数
Delta_max = 10;
Delta = 1;
eta = 0.15;
max_iter = 100;
tolerance = 1e-8;

lambda_k = lambda_0;

% 预分配历史记录
history = struct();
history.lambda = zeros(5, max_iter);
history.Psi = zeros(1, max_iter);
history.Delta = zeros(1, max_iter);
history.status = cell(1, max_iter);

fprintf('初值: α=%.2f°, β=%.2f°, p=[%.1f,%.1f,%.1f]mm\n\n', ...
    lambda_0(1), lambda_0(2), lambda_0(3:5));
fprintf('Iter\t α(°)\t\t β(°)\t\t ||p||(mm)\t Ψ(λ)\t\t Δ\t\t 状态\n');
fprintf('-------------------------------------------------------------------------------------\n');

actual_iters = max_iter;

for iter = 1:max_iter
    % 计算当前准则函数
    Psi_k = evaluate_criterion(P_measured, lambda_k, R, K, A4, A6);
    
    % 记录历史
    history.lambda(:, iter) = lambda_k;
    history.Psi(iter) = Psi_k;
    history.Delta(iter) = Delta;
    
    % 计算解析梯度和Hessian
    [grad, H] = compute_gradient_hessian_analytic(P_measured, lambda_k, R, K, A4, A6);
    
    % 添加正则化
    H = H + 1e-6 * eye(5);
    
    % 求解信赖域子问题
    delta_lambda = solve_trust_region_subproblem(grad, H, Delta);
    
    % 尝试新参数
    lambda_new = lambda_k + delta_lambda;
    Psi_new = evaluate_criterion(P_measured, lambda_new, R, K, A4, A6);
    
    % 计算信赖域比率
    actual_reduction = Psi_k - Psi_new;
    predicted_reduction = -(grad' * delta_lambda + 0.5 * delta_lambda' * H * delta_lambda);
    
    if abs(predicted_reduction) < 1e-12
        rho = 0;
    else
        rho = actual_reduction / predicted_reduction;
    end
    
    % 更新策略
    if rho > eta
        lambda_k = lambda_new;
        status = '接受';
        
        if rho > 0.75 && Delta < Delta_max
            Delta = min(2 * Delta, Delta_max);
        end
    else
        status = '拒绝';
        Delta = Delta / 2;
    end
    
    history.status{iter} = status;
    
    fprintf('%2d\t %.6f\t %.6f\t %.6f\t %.6e\t %.4f\t %s\n', ...
        iter, lambda_k(1), lambda_k(2), norm(lambda_k(3:5)), Psi_k, Delta, status);
    
    % 收敛判断
    if Psi_k < tolerance
        actual_iters = iter;
        fprintf('\n✓ 收敛(准则函数<阈值)! 迭代%d次\n', iter);
        break;
    end
    
    if norm(delta_lambda) < tolerance && strcmp(status, '接受')
        actual_iters = iter;
        fprintf('\n✓ 收敛(步长<阈值)! 迭代%d次\n', iter);
        break;
    end
    
    if Delta < 1e-8
        actual_iters = iter;
        fprintf('\n⚠ 信赖域过小，终止迭代\n');
        break;
    end
end

% 裁剪历史
history.lambda = history.lambda(:, 1:actual_iters);
history.Psi = history.Psi(1:actual_iters);
history.Delta = history.Delta(1:actual_iters);
history.status = history.status(1:actual_iters);

alpha_SIL = lambda_k(1);
beta_SIL = lambda_k(2);
p_SIL = lambda_k(3:5);

rmse_SIL = sqrt(Psi_k / N_points);

fprintf('\n【SIL算法结果】\n');
fprintf('  估计值: α=%.6f°, β=%.6f°, p=[%.3f, %.3f, %.3f]mm\n', ...
    alpha_SIL, beta_SIL, p_SIL);
fprintf('  真实值: α=%.6f°, β=%.6f°, p=[%.3f, %.3f, %.3f]mm\n', ...
    alpha_true, beta_true, p_true);
fprintf('  误  差: Δα=%.6f° (%.2f〞), Δβ=%.6f° (%.2f〞), Δp=%.6fmm\n', ...
    abs(alpha_SIL-alpha_true), abs(alpha_SIL-alpha_true)*3600, ...
    abs(beta_SIL-beta_true), abs(beta_SIL-beta_true)*3600, ...
    norm(p_SIL-p_true));
fprintf('  RMSE: %.4fmm (%.1fμm)\n\n', rmse_SIL, rmse_SIL*1000);

%% ========================================================================
%% 3. 可视化
%% ========================================================================
fprintf('【生成可视化】\n');

figure('Position', [50, 50, 1600, 800], 'Name', 'SIL算法结果');

% 子图1: 准则函数收敛
subplot(2,3,1);
semilogy(1:actual_iters, history.Psi, 'b-o', 'LineWidth', 1.5, 'MarkerSize', 5);
xlabel('迭代次数');
ylabel('Ψ(λ)');
title('准则函数收敛曲线');
grid on;
xlim([1, actual_iters]);

% 子图2: 信赖域半径
subplot(2,3,2);
plot(1:actual_iters, history.Delta, 'r-s', 'LineWidth', 1.5, 'MarkerSize', 5);
xlabel('迭代次数');
ylabel('Δ');
title('信赖域半径变化');
grid on;
xlim([1, actual_iters]);

% 子图3: 角度参数收敛
subplot(2,3,3);
plot(1:actual_iters, history.lambda(1,:), 'b-', 'LineWidth', 1.5, 'DisplayName', 'α估计');
hold on;
plot(1:actual_iters, history.lambda(2,:), 'r-', 'LineWidth', 1.5, 'DisplayName', 'β估计');
yline(alpha_true, 'b--', 'LineWidth', 1.5, 'DisplayName', 'α真值');
yline(beta_true, 'r--', 'LineWidth', 1.5, 'DisplayName', 'β真值');
xlabel('迭代次数');
ylabel('角度(°)');
title('旋转角收敛');
legend('Location', 'best');
grid on;
xlim([1, actual_iters]);

% 子图4: 平移参数收敛
subplot(2,3,4);
plot(1:actual_iters, history.lambda(3,:), 'b-', 'LineWidth', 1.5, 'DisplayName', 'px');
hold on;
plot(1:actual_iters, history.lambda(4,:), 'r-', 'LineWidth', 1.5, 'DisplayName', 'py');
plot(1:actual_iters, history.lambda(5,:), 'g-', 'LineWidth', 1.5, 'DisplayName', 'pz');
yline(px_true, 'b--', 'LineWidth', 1);
yline(py_true, 'r--', 'LineWidth', 1);
yline(pz_true, 'g--', 'LineWidth', 1);
xlabel('迭代次数');
ylabel('平移(mm)');
title('平移向量收敛');
legend('Location', 'best');
grid on;
xlim([1, actual_iters]);

% 子图5: 配准残差分布
subplot(2,3,5);
Rx_final = [1, 0, 0;
            0, cosd(alpha_SIL), -sind(alpha_SIL);
            0, sind(alpha_SIL), cosd(alpha_SIL)];
Ry_final = [cosd(beta_SIL), 0, sind(beta_SIL);
            0, 1, 0;
           -sind(beta_SIL), 0, cosd(beta_SIL)];
R_SIL = Ry_final * Rx_final;

residuals_final = zeros(N_points, 1);
for i = 1:N_points
    p_i = P_measured(i, :)';
    p_transformed = R_SIL' * (p_i - p_SIL);
    z_surface = compute_aspherical_z(p_transformed(1), p_transformed(2), R, K, A4, A6);
    if ~isnan(z_surface)
        residuals_final(i) = abs(z_surface - p_transformed(3));
    end
end

stem(1:N_points, residuals_final*1000, 'filled', 'LineWidth', 1.5);
hold on;
yline(mean(residuals_final*1000), 'r--', 'LineWidth', 2, 'DisplayName', '平均值');
xlabel('测量点编号');
ylabel('残差(μm)');
title(sprintf('配准残差 (RMSE=%.1fμm)', rmse_SIL*1000));
legend('Location', 'best');
grid on;

% 子图6: 接受/拒绝统计
subplot(2,3,6);
accept_count = sum(strcmp(history.status, '接受'));
reject_count = sum(strcmp(history.status, '拒绝'));
bar([accept_count, reject_count]);
set(gca, 'XTickLabel', {'接受', '拒绝'});
ylabel('次数');
title('迭代步长统计');
text(1, accept_count+1, num2str(accept_count), 'HorizontalAlignment', 'center');
text(2, reject_count+1, num2str(reject_count), 'HorizontalAlignment', 'center');
grid on;

fprintf('可视化完成!\n');

%% ========================================================================
%% 辅助函数
%% ========================================================================

function z = compute_aspherical_z(x, y, R, K, A4, A6)
    rho = sqrt(x^2 + y^2);
    c = 1 / R;
    discriminant = 1 - (1 + K) * c^2 * rho^2;
    
    if discriminant >= 0
        z = (c * rho^2) / (1 + sqrt(discriminant)) + A4 * rho^4 + A6 * rho^6;
    else
        z = NaN;
    end
end

function z_W = compute_measured_z_correct(x_W, y_W, R_true, p_true, R, K, A4, A6)
    R_inv = R_true';
    z_ideal = compute_aspherical_z(x_W, y_W, R, K, A4, A6);
    z_W = z_ideal + p_true(3);
    
    max_iter = 100;
    tol = 1e-9;
    
    for iter = 1:max_iter
        p_W = [x_W; y_W; z_W];
        p_M = R_inv * (p_W - p_true);
        x_M = p_M(1);
        y_M = p_M(2);
        z_M = p_M(3);
        
        z_M_theory = compute_aspherical_z(x_M, y_M, R, K, A4, A6);
        
        if isnan(z_M_theory)
            z_W = NaN;
            return;
        end
        
        residual = z_M - z_M_theory;
        
        if abs(residual) < tol
            break;
        end
        
        rho = sqrt(x_M^2 + y_M^2);
        c = 1 / R;
        discriminant = 1 - (1 + K) * c^2 * rho^2;
        
        if rho > 1e-8 && discriminant > 1e-10
            sqrt_disc = sqrt(discriminant);
            dz_drho = (c * 2 * rho) / (1 + sqrt_disc) ...
                      + (c^3 * (1+K) * rho^3) / ((1 + sqrt_disc)^2 * sqrt_disc) ...
                      + 4 * A4 * rho^3 + 6 * A6 * rho^5;
            
            dz_dx_M = dz_drho * (x_M / rho);
            dz_dy_M = dz_drho * (y_M / rho);
            
            J = R_inv(3,3) - dz_dx_M*R_inv(1,3) - dz_dy_M*R_inv(2,3);
        else
            J = R_inv(3,3);
        end
        
        if abs(J) > 1e-12
            z_W = z_W - residual / J;
        else
            break;
        end
    end
end

function Psi = evaluate_criterion(P_measured, lambda, R, K, A4, A6)
    alpha = lambda(1);
    beta = lambda(2);
    p = lambda(3:5);
    
    Rx = [1, 0, 0;
          0, cosd(alpha), -sind(alpha);
          0, sind(alpha), cosd(alpha)];
    Ry = [cosd(beta), 0, sind(beta);
          0, 1, 0;
         -sind(beta), 0, cosd(beta)];
    R_mat = Ry * Rx;
    
    Psi = 0;
    N_points = size(P_measured, 1);
    
    for i = 1:N_points
        p_i = P_measured(i, :)';
        p_transformed = R_mat' * (p_i - p);
        
        x_prime = p_transformed(1);
        y_prime = p_transformed(2);
        z_prime = p_transformed(3);
        
        z_surface = compute_aspherical_z(x_prime, y_prime, R, K, A4, A6);
        
        if ~isnan(z_surface)
            Psi = Psi + (z_surface - z_prime)^2;
        end
    end
end

function [grad, H] = compute_gradient_hessian_analytic(P_measured, lambda, R, K, A4, A6)
    alpha = lambda(1);
    beta = lambda(2);
    p = lambda(3:5);
    
    N_points = size(P_measured, 1);
    
    % 构建旋转矩阵
    Rx = [1, 0, 0;
          0, cosd(alpha), -sind(alpha);
          0, sind(alpha), cosd(alpha)];
    Ry = [cosd(beta), 0, sind(beta);
          0, 1, 0;
         -sind(beta), 0, cosd(beta)];
    R_mat = Ry * Rx;
    
    % 旋转矩阵的导数（弧度制）
    dRx_dalpha = [0, 0, 0;
                  0, -sind(alpha), -cosd(alpha);
                  0, cosd(alpha), -sind(alpha)] * (pi/180);
    
    dRy_dbeta = [-sind(beta), 0, cosd(beta);
                 0, 0, 0;
                -cosd(beta), 0, -sind(beta)] * (pi/180);
    
    dR_dalpha = Ry * dRx_dalpha;
    dR_dbeta = dRy_dbeta * Rx;
    
    % 初始化
    grad = zeros(5, 1);
    H = zeros(5, 5);
    
    for i = 1:N_points
        p_i = P_measured(i, :)';
        p_diff = p_i - p;
        
        % 变换到工件系
        p_prime = R_mat' * p_diff;
        x_prime = p_prime(1);
        y_prime = p_prime(2);
        z_prime = p_prime(3);
        
        % 非球面Z值
        z_surf = compute_aspherical_z(x_prime, y_prime, R, K, A4, A6);
        
        if isnan(z_surf)
            continue;
        end
        
        % 残差
        r_i = z_surf - z_prime;
        
        % 非球面偏导数
        [df_dx, df_dy] = compute_surface_derivatives(x_prime, y_prime, R, K, A4, A6);
        
        if isnan(df_dx)
            continue;
        end
        
        % 变换后坐标对参数的导数
        dp_dalpha = dR_dalpha' * p_diff;
        dp_dbeta = dR_dbeta' * p_diff;
        dp_dp = -R_mat';
        
        % 残差对参数的导数（链式法则）
        dr_dalpha = df_dx * dp_dalpha(1) + df_dy * dp_dalpha(2) - dp_dalpha(3);
        dr_dbeta = df_dx * dp_dbeta(1) + df_dy * dp_dbeta(2) - dp_dbeta(3);
        
        dr_dp = zeros(3, 1);
        for k = 1:3
            dr_dp(k) = df_dx * dp_dp(1, k) + df_dy * dp_dp(2, k) - dp_dp(3, k);
        end
        
        % 梯度：∂Ψ/∂λ = 2 * Σ r_i * (∂r_i/∂λ)
        grad(1) = grad(1) + 2 * r_i * dr_dalpha;
        grad(2) = grad(2) + 2 * r_i * dr_dbeta;
        grad(3:5) = grad(3:5) + 2 * r_i * dr_dp;
        
        % Hessian（Gauss-Newton近似）
        J_i = [dr_dalpha; dr_dbeta; dr_dp];
        H = H + 2 * (J_i * J_i');
    end
end

function [df_dx, df_dy] = compute_surface_derivatives(x, y, R, K, A4, A6)
    rho = sqrt(x^2 + y^2);
    
    if rho < 1e-10
        df_dx = 0;
        df_dy = 0;
        return;
    end
    
    c = 1 / R;
    discriminant = 1 - (1 + K) * c^2 * rho^2;
    
    if discriminant <= 0
        df_dx = NaN;
        df_dy = NaN;
        return;
    end
    
    sqrt_disc = sqrt(discriminant);
    
    % ∂f/∂ρ
    df_drho = (c * 2 * rho) / (1 + sqrt_disc) ...
              + (c^3 * (1+K) * rho^3) / ((1 + sqrt_disc)^2 * sqrt_disc) ...
              + 4 * A4 * rho^3 + 6 * A6 * rho^5;
    
    % 链式法则
    df_dx = df_drho * (x / rho);
    df_dy = df_drho * (y / rho);
end

function s = solve_trust_region_subproblem(grad, H, Delta)
    g_norm = norm(grad);
    if g_norm < 1e-12
        s = zeros(size(grad));
        return;
    end
    
    % 无约束Newton步
    if rcond(H) > 1e-10
        s_newton = -H \ grad;
    else
        s_newton = -pinv(H) * grad;
    end
    
    % Newton步在信赖域内
    if norm(s_newton) <= Delta
        s = s_newton;
        return;
    end
    
    % Cauchy步
    tau = min(1, Delta / g_norm);
    s_cauchy = -tau * Delta / g_norm * grad;
    
    if norm(s_cauchy) >= Delta
        s = s_cauchy;
        return;
    end
    
    % Dogleg路径
    a = norm(s_newton - s_cauchy)^2;
    b = 2 * s_cauchy' * (s_newton - s_cauchy);
    c = norm(s_cauchy)^2 - Delta^2;
    
    discriminant = b^2 - 4*a*c;
    if discriminant >= 0
        tau = (-b + sqrt(discriminant)) / (2*a);
        tau = max(0, min(1, tau));
    else
        tau = 1;
    end
    
    s = s_cauchy + tau * (s_newton - s_cauchy);
end














%% ========== 测试示例 ==========
clear; clc;

% 非球面参数
R = 1000;
K = -2;
A4 = 0;
A6 = 0;

% 工件位姿
alpha_true = 2;    % 度
beta_true = 1.5;
t_true = [10; -8; 10];  % mm

Rx = [1, 0, 0;
      0, cosd(alpha_true), -sind(alpha_true);
      0, sind(alpha_true),  cosd(alpha_true)];
Ry = [cosd(beta_true), 0, sind(beta_true);
      0, 1, 0;
     -sind(beta_true), 0, cosd(beta_true)];
R_true = Ry * Rx;

% 测试点: 机床坐标系 (1, 2, ?)
x_W = 1;
y_W = 2;

fprintf('========== 固定XY点的Z值求解 ==========\n\n');
fprintf('【工件位姿】\n');
fprintf('  旋转角: α=%.2f°, β=%.2f°\n', alpha_true, beta_true);
fprintf('  平移: t=[%.1f, %.1f, %.1f]mm\n\n', t_true);

fprintf('【查询点】机床坐标系\n');
fprintf('  固定XY: (%.1f, %.1f, ?)\n\n', x_W, y_W);

% === 方法1: 原始状态(无变换) ===
z_original = compute_aspherical_z(x_W, y_W, R, K, A4, A6);
fprintf('【方法1】原始状态(工件未变换)\n');
fprintf('  直接代入: z = %.6f mm\n\n', z_original);

% === 方法2: 精确求解(考虑变换) ===
tic;
z_transformed = compute_z_at_fixed_xy(x_W, y_W, R_true, t_true, R, K, A4, A6);
time_elapsed = toc;

fprintf('【方法2】变换后状态(精确迭代)\n');
fprintf('  求解结果: z = %.6f mm\n', z_transformed);
fprintf('  计算耗时: %.3f ms\n', time_elapsed*1000);
fprintf('  Z值差异: Δz = %.6f mm (%.1f μm)\n\n', ...
        abs(z_transformed - z_original), ...
        abs(z_transformed - z_original)*1000);

% === 验证正确性 ===
fprintf('【验证】反变换检查\n');
p_W_final = [x_W; y_W; z_transformed];
p_M_check = R_true' * (p_W_final - t_true);

fprintf('  反变换到工件坐标系:\n');
fprintf('    x_M = %.6f mm\n', p_M_check(1));
fprintf('    y_M = %.6f mm\n', p_M_check(2));
fprintf('    z_M = %.6f mm\n', p_M_check(3));

% 检查是否在非球面上
z_M_theory = compute_aspherical_z(p_M_check(1), p_M_check(2), R, K, A4, A6);
error_surface = abs(p_M_check(3) - z_M_theory);

fprintf('  非球面约束:\n');
fprintf('    理论Z: %.6f mm\n', z_M_theory);
fprintf('    实际Z: %.6f mm\n', p_M_check(3));
fprintf('    约束误差: %.2e mm ', error_surface);

if error_surface < 1e-9
    fprintf('✓\n');
else
    fprintf('✗ 误差过大!\n');
end


function z_W = compute_z_at_fixed_xy(x_W, y_W, R_true, t_true, R, K, A4, A6)
    % 计算旋转平移后,机床坐标系固定XY点对应的非球面Z值
    % 
    % 输入:
    %   x_W, y_W - 机床坐标系的XY坐标(固定)
    %   R_true   - 工件旋转矩阵 (3×3)
    %   t_true   - 工件平移向量 (3×1)
    %   R, K, A4, A6 - 非球面参数
    % 输出:
    %   z_W - 对应的机床坐标系Z值
    
    % === 初始猜测 ===
    % 方法1: 假设只有平移(小角度近似)
    rho0 = sqrt(x_W^2 + y_W^2);
    z_M0 = compute_aspherical_z(x_W, y_W, R, K, A4, A6);
    z_W = z_M0 + t_true(3);  % 粗略初值
    
    % === Newton-Raphson迭代 ===
    max_iter = 100;
    tol = 1e-10;
    R_inv = R_true';  % 预计算逆矩阵
    
    for iter = 1:max_iter
        % 1. 构建当前机床坐标点
        p_W = [x_W; y_W; z_W];
        
        % 2. 变换到工件坐标系
        p_M = R_inv * (p_W - t_true);
        x_M = p_M(1);
        y_M = p_M(2);
        z_M = p_M(3);
        
        % 3. 计算该点在非球面上的理论Z值
        z_M_theory = compute_aspherical_z(x_M, y_M, R, K, A4, A6);
        
        if isnan(z_M_theory)
            warning('点(%.1f, %.1f)超出非球面有效口径', x_W, y_W);
            z_W = NaN;
            return;
        end
        
        % 4. 计算残差
        residual = z_M - z_M_theory;
        
        % 5. 收敛判断
        if abs(residual) < tol
            return;  % 成功收敛
        end
        
        % 6. 计算Jacobian矩阵
        rho_M = sqrt(x_M^2 + y_M^2);
        c = 1 / R;
        discriminant = 1 - (1 + K) * c^2 * rho_M^2;
        
        if rho_M > 1e-8 && discriminant > 1e-10
            % 计算 ∂f/∂ρ
            sqrt_disc = sqrt(discriminant);
            df_drho = (2*c*rho_M) / (1 + sqrt_disc) ...
                      + (c^3*(1+K)*rho_M^3) / ((1+sqrt_disc)^2 * sqrt_disc) ...
                      + 4*A4*rho_M^3 + 6*A6*rho_M^5;
            
            % 链式法则: ∂f/∂x_M, ∂f/∂y_M
            if rho_M > 1e-8
                df_dx = df_drho * (x_M / rho_M);
                df_dy = df_drho * (y_M / rho_M);
            else
                df_dx = 0;
                df_dy = 0;
            end
            
            % 总Jacobian: dF/dz_W
            % 由 p_M = R^T*(p_W - t) 可得:
            % ∂x_M/∂z_W = R_inv(1,3)
            % ∂y_M/∂z_W = R_inv(2,3)
            % ∂z_M/∂z_W = R_inv(3,3)
            J = R_inv(3,3) - df_dx*R_inv(1,3) - df_dy*R_inv(2,3);
        else
            % 中心点或奇异位置
            J = R_inv(3,3);
        end
        
        % 7. Newton更新
        if abs(J) > 1e-12
            z_W = z_W - residual / J;
        else
            warning('Jacobian接近奇异,迭代终止');
            break;
        end
    end
    
    if iter == max_iter
        warning('迭代未收敛 (x_W=%.1f, y_W=%.1f, 残差=%.2e)', ...
                x_W, y_W, abs(residual));
    end
end

function z = compute_aspherical_z(x, y, R, K, A4, A6)
    % 非球面方程(式2.27)
    rho = sqrt(x^2 + y^2);
    c = 1 / R;
    discriminant = 1 - (1 + K) * c^2 * rho^2;
    
    if discriminant >= 0
        z = (c * rho^2) / (1 + sqrt(discriminant)) + ...
            A4 * rho^4 + A6 * rho^6;
    else
        z = NaN;
    end
end
















