
%% ========================================================================
%% 非球面工件位姿求解 - 完整版(包含三种配准算法)
%% ========================================================================
clear; clc; close all;

%% 参数设置
R = 1000; K = -2; A4 = 0; A6 = 0;
aperture_size = 300;

% 真实姿态
alpha_true = 2;   % 度
beta_true = 1.5;
px_true = 10;
py_true = -8;
pz_true = 10;

sigma_noise = 0.01;  % mm

% 构建旋转矩阵
Rx_true = [1, 0, 0;
           0, cosd(alpha_true), -sind(alpha_true);
           0, sind(alpha_true), cosd(alpha_true)];
Ry_true = [cosd(beta_true), 0, sind(beta_true);
           0, 1, 0;
          -sind(beta_true), 0, cosd(beta_true)];
R_true = Ry_true * Rx_true;
p_true = [px_true; py_true; pz_true];

fprintf('========== 非球面位姿求解仿真 ==========\n\n');
fprintf('【参数设置】\n');
fprintf('  非球面: R=%d mm, K=%.1f\n', R, K);
fprintf('  真实姿态: α=%.1f°, β=%.1f°, p=[%.1f,%.1f,%.1f]mm\n', ...
    alpha_true, beta_true, px_true, py_true, pz_true);
fprintf('  测量噪声: σ=%.2f mm\n\n', sigma_noise);

%% ========================================================================
%% 生成测量数据
%% ========================================================================
fprintf('【生成实际测量数据】\n');

% 步骤1: 定义采样网格(极坐标)
num_rings = 2;
points_per_ring = 8;

sample_points = [0, 0];  % 中心点
for ring = 1:num_rings
    radius = aperture_size/2 * ring / num_rings;
    angles = linspace(0, 2*pi*(1-1/points_per_ring), points_per_ring);
    for theta = angles
        x = radius * cos(theta);
        y = radius * sin(theta);
        sample_points = [sample_points; x, y];
    end
end

N_points = size(sample_points, 1);

% 步骤2: 计算模型点Q(理想非球面)
Q_model = zeros(N_points, 3);
for i = 1:N_points
    x = sample_points(i, 1);
    y = sample_points(i, 2);
    z = compute_aspherical_z(x, y, R, K, A4, A6);
    Q_model(i, :) = [x, y, z];
end

% 步骤3: 计算实际测量点P(XY不变,Z是倾斜后的真实值)
P_measured = zeros(N_points, 3);

fprintf('  计算倾斜工件表面Z坐标...\n');
for i = 1:N_points
    x_W = sample_points(i, 1);
    y_W = sample_points(i, 2);
    z_W = compute_measured_z(x_W, y_W, R_true, p_true, R, K, A4, A6);
    P_measured(i, :) = [x_W, y_W, z_W];
    
    if mod(i, 5) == 0
        fprintf('    进度: %d/%d\n', i, N_points);
    end
end

% 步骤4: 添加测量噪声
P_measured = P_measured + sigma_noise * randn(size(P_measured));

z_diff = P_measured(:,3) - Q_model(:,3);
fprintf('  完成! 测量点数N=%d\n', N_points);
fprintf('  Z偏差: 均值=%.3fmm, 标准差=%.3fmm\n\n', mean(z_diff), std(z_diff));

%% ========================================================================
%% 算法1: Newton-Gauss迭代法
%% ========================================================================
fprintf('========== 算法1: Newton-Gauss迭代法 ==========\n');

% 验证输入
if size(Q_model,1) ~= size(P_measured,1)
    error('模型点和测量点数量不一致!');
end

% 初始化
alpha_0 = 0; beta_0 = 0; p_0 = [0; 0; 0];
max_iter = 50;
tolerance = 1e-6;

history_NG = struct();
history_NG.alpha = [];
history_NG.beta = [];
history_NG.px = [];
history_NG.py = [];
history_NG.pz = [];
history_NG.error = [];

alpha_k = alpha_0;
beta_k = beta_0;
p_k = p_0;

fprintf('初值: α=%.2f°, β=%.2f°, p=[%.1f,%.1f,%.1f]mm\n', alpha_0, beta_0, p_0);
fprintf('收敛条件: e(η)<%.2e 或 ||Δη||<%.2e\n\n', tolerance, tolerance);
fprintf('Iter\t α(°)\t\t β(°)\t\t ||p||(mm)\t e(η)\t\t ||Δη||\n');
fprintf('-------------------------------------------------------------------------\n');

% 迭代求解
for iter = 1:max_iter
    % 构建旋转矩阵
    Rx_k = [1, 0, 0;
            0, cosd(alpha_k), -sind(alpha_k);
            0, sind(alpha_k), cosd(alpha_k)];
    Ry_k = [cosd(beta_k), 0, sind(beta_k);
            0, 1, 0;
           -sind(beta_k), 0, cosd(beta_k)];
    R_k = Ry_k * Rx_k;
    
    % 计算残差
    residuals = zeros(N_points, 3);
    for i = 1:N_points
        q_i = Q_model(i, :)';
        p_i = P_measured(i, :)';
        residuals(i, :) = (R_k' * (p_i - p_k) - q_i)';
    end
    
    % 准则函数
    e_k = sum(sum(residuals.^2));
    
    % 记录历史
    history_NG.alpha(iter) = alpha_k;
    history_NG.beta(iter) = beta_k;
    history_NG.px(iter) = p_k(1);
    history_NG.py(iter) = p_k(2);
    history_NG.pz(iter) = p_k(3);
    history_NG.error(iter) = e_k;
    
    % 构建Jacobian
    J = zeros(3*N_points, 5);
    r_vec = reshape(residuals', [], 1);
    
    for i = 1:N_points
        q_i = Q_model(i, :)';
        p_i = P_measured(i, :)';
        
        dRx_dalpha = [0, 0, 0;
                      0, -sind(alpha_k), -cosd(alpha_k);
                      0, cosd(alpha_k), -sind(alpha_k)] * (pi/180);
        dR_dalpha = Ry_k * dRx_dalpha;
        
        dRy_dbeta = [-sind(beta_k), 0, cosd(beta_k);
                     0, 0, 0;
                    -cosd(beta_k), 0, -sind(beta_k)] * (pi/180);
        dR_dbeta = dRy_dbeta * Rx_k;
        
        row_idx = (i-1)*3 + 1;
        J(row_idx:row_idx+2, 1) = dR_dalpha' * (p_i - p_k);
        J(row_idx:row_idx+2, 2) = dR_dbeta' * (p_i - p_k);
        J(row_idx:row_idx+2, 3:5) = -R_k';
    end
    
    % Newton更新
    JTJ = J' * J;
    JTr = J' * r_vec;
    
    % 检查条件数
    if iter == 1
        cond_num = cond(JTJ);
        if cond_num > 1e12
            warning('Jacobian矩阵病态(条件数=%.2e)', cond_num);
        end
    end
    
    delta_eta = -JTJ \ JTr;
    
    % 输出
    fprintf('%2d\t %.6f\t %.6f\t %.6f\t %.6e\t %.6e\n', ...
        iter, alpha_k, beta_k, norm(p_k), e_k, norm(delta_eta));
    
    % 收敛判断
    converged = false;
    if e_k < tolerance
        fprintf('\n✓ 收敛(准则函数<阈值), 迭代%d次\n', iter);
        converged = true;
    elseif norm(delta_eta) < tolerance
        fprintf('\n✓ 收敛(步长<阈值), 迭代%d次\n', iter);
        converged = true;
    elseif iter > 1 && abs(e_k - history_NG.error(iter-1)) < tolerance * 0.1
        fprintf('\n✓ 收敛(准则函数变化极小), 迭代%d次\n', iter);
        converged = true;
    end
    
    if converged
        break;
    end
    
    % 更新参数
    alpha_k = alpha_k + delta_eta(1);
    beta_k = beta_k + delta_eta(2);
    p_k = p_k + delta_eta(3:5);
    
    if iter == max_iter
        fprintf('\n⚠ 警告: 达到最大迭代次数(%d)未收敛!\n', max_iter);
    end
end

R_NG = Ry_k * Rx_k;
p_NG = p_k;

% 输出结果
fprintf('\n【Newton-Gauss法结果】\n');
fprintf('  估计位姿: α=%.6f°, β=%.6f°, p=[%.6f,%.6f,%.6f]mm\n', ...
    alpha_k, beta_k, p_k);
fprintf('  误差: Δα=%.6f° (%.2f角秒), Δβ=%.6f° (%.2f角秒), Δp=%.6fmm\n', ...
    abs(alpha_k-alpha_true), abs(alpha_k-alpha_true)*3600, ...
    abs(beta_k-beta_true), abs(beta_k-beta_true)*3600, norm(p_k-p_true));
fprintf('  RMSE=%.4fmm (%.2fμm)\n\n', ...
    sqrt(e_k/N_points), sqrt(e_k/N_points)*1000);

%% ========================================================================
%% 算法2: Levenberg-Marquardt法
%% ========================================================================
fprintf('========== 算法2: Levenberg-Marquardt法 ==========\n');

alpha_lm = alpha_0;
beta_lm = beta_0;
p_lm = p_0;
lambda = 0.01;

history_LM = struct();
history_LM.alpha = [];
history_LM.beta = [];
history_LM.px = [];
history_LM.py = [];
history_LM.pz = [];
history_LM.error = [];
history_LM.lambda = [];

fprintf('初始阻尼因子: λ=%.4f\n\n', lambda);
fprintf('Iter\t α(°)\t\t β(°)\t\t ||p||(mm)\t e(η)\t\t λ\t\t 状态\n');
fprintf('-------------------------------------------------------------------------------------\n');

for iter = 1:max_iter
    % 构建旋转矩阵
    Rx_lm = [1, 0, 0;
             0, cosd(alpha_lm), -sind(alpha_lm);
             0, sind(alpha_lm), cosd(alpha_lm)];
    Ry_lm = [cosd(beta_lm), 0, sind(beta_lm);
             0, 1, 0;
            -sind(beta_lm), 0, cosd(beta_lm)];
    R_lm = Ry_lm * Rx_lm;
    
    % 计算残差
    residuals = zeros(N_points, 3);
    for i = 1:N_points
        q_i = Q_model(i, :)';
        p_i = P_measured(i, :)';
        residuals(i, :) = (R_lm' * (p_i - p_lm) - q_i)';
    end
    e_lm = sum(sum(residuals.^2));
    
    % 记录历史
    history_LM.alpha(iter) = alpha_lm;
    history_LM.beta(iter) = beta_lm;
    history_LM.px(iter) = p_lm(1);
    history_LM.py(iter) = p_lm(2);
    history_LM.pz(iter) = p_lm(3);
    history_LM.error(iter) = e_lm;
    history_LM.lambda(iter) = lambda;
    
    % 构建Jacobian
    J = zeros(3*N_points, 5);
    r_vec = reshape(residuals', [], 1);
    
    for i = 1:N_points
        q_i = Q_model(i, :)';
        p_i = P_measured(i, :)';
        
        dRx_dalpha = [0, 0, 0;
                      0, -sind(alpha_lm), -cosd(alpha_lm);
                      0, cosd(alpha_lm), -sind(alpha_lm)] * (pi/180);
        dR_dalpha = Ry_lm * dRx_dalpha;
        
        dRy_dbeta = [-sind(beta_lm), 0, cosd(beta_lm);
                     0, 0, 0;
                    -cosd(beta_lm), 0, -sind(beta_lm)] * (pi/180);
        dR_dbeta = dRy_dbeta * Rx_lm;
        
        row_idx = (i-1)*3 + 1;
        J(row_idx:row_idx+2, 1) = dR_dalpha' * (p_i - p_lm);
        J(row_idx:row_idx+2, 2) = dR_dbeta' * (p_i - p_lm);
        J(row_idx:row_idx+2, 3:5) = -R_lm';
    end
    
    % LM更新
    A = J' * J;
    b = J' * r_vec;
    delta_eta = -(A + lambda * eye(5)) \ b;
    
    % 尝试更新
    alpha_new = alpha_lm + delta_eta(1);
    beta_new = beta_lm + delta_eta(2);
    p_new = p_lm + delta_eta(3:5);
    
    % 计算新误差
    Rx_new = [1, 0, 0;
              0, cosd(alpha_new), -sind(alpha_new);
              0, sind(alpha_new), cosd(alpha_new)];
    Ry_new = [cosd(beta_new), 0, sind(beta_new);
              0, 1, 0;
             -sind(beta_new), 0, cosd(beta_new)];
    R_new = Ry_new * Rx_new;
    
    residuals_new = zeros(N_points, 3);
    for i = 1:N_points
        q_i = Q_model(i, :)';
        p_i = P_measured(i, :)';
        residuals_new(i, :) = (R_new' * (p_i - p_new) - q_i)';
    end
    e_new = sum(sum(residuals_new.^2));
    
    % 自适应调整λ
    if e_new < e_lm
        status = '接受';
        alpha_lm = alpha_new;
        beta_lm = beta_new;
        p_lm = p_new;
        lambda = max(lambda / 10, 1e-10);
    else
        status = '拒绝';
        lambda = min(lambda * 10, 1e10);
    end
    
    fprintf('%2d\t %.6f\t %.6f\t %.6f\t %.6e\t %.4e\t %s\n', ...
        iter, alpha_lm, beta_lm, norm(p_lm), e_lm, lambda, status);
    
    % 收敛判断
    if e_lm < tolerance
        fprintf('\n✓ 收敛! 迭代%d次\n', iter);
        break;
    end
    
    if iter == max_iter
        fprintf('\n⚠ 警告: 达到最大迭代次数(%d)\n', max_iter);
    end
end

R_LM = Ry_lm * Rx_lm;  % 使用最终接受的参数
p_LM = p_lm;

fprintf('\n【Levenberg-Marquardt法结果】\n');
fprintf('  估计位姿: α=%.6f°, β=%.6f°, p=[%.6f,%.6f,%.6f]mm\n', ...
    alpha_lm, beta_lm, p_lm);
fprintf('  误差: Δα=%.6f°, Δβ=%.6f°, Δp=%.6fmm\n', ...
    abs(alpha_lm-alpha_true), abs(beta_lm-beta_true), norm(p_lm-p_true));
fprintf('  RMSE=%.4fmm (%.2fμm)\n\n', ...
    sqrt(e_lm/N_points), sqrt(e_lm/N_points)*1000);

%% ========================================================================
%% 算法3: SVD闭式解
%% ========================================================================
fprintf('========== 算法3: SVD闭式解 ==========\n');

centroid_P = mean(P_measured, 1)';
centroid_Q = mean(Q_model, 1)';

P_centered = P_measured - centroid_P';
Q_centered = Q_model - centroid_Q';

H = Q_centered' * P_centered;
[U, ~, V] = svd(H);

R_SVD = V * U';
if det(R_SVD) < 0
    V(:, 3) = -V(:, 3);
    R_SVD = V * U';
end

p_SVD = centroid_Q - R_SVD * centroid_P;

% 提取欧拉角(修正版)
beta_svd = asind(-R_SVD(3,1));
if abs(cosd(beta_svd)) > 1e-6
    alpha_svd = atan2d(R_SVD(3,2), R_SVD(3,3));
else
    alpha_svd = atan2d(-R_SVD(2,3), R_SVD(2,2));
    warning('SVD: 接近万向节锁');
end

% 计算残差
residuals_SVD = vecnorm((R_SVD*Q_model')' + p_SVD' - P_measured, 2, 2);
rmse_SVD = sqrt(mean(residuals_SVD.^2));

fprintf('  估计位姿: α=%.6f°, β=%.6f°, p=[%.6f,%.6f,%.6f]mm\n', ...
    alpha_svd, beta_svd, p_SVD);
fprintf('  误差: Δα=%.6f°, Δβ=%.6f°, Δp=%.6fmm\n', ...
    abs(alpha_svd-alpha_true), abs(beta_svd-beta_true), norm(p_SVD-p_true));
fprintf('  RMSE=%.4fmm (%.2fμm)\n\n', rmse_SVD, rmse_SVD*1000);

%% ========================================================================
%% 可视化结果
%% ========================================================================
fprintf('========== 生成可视化 ==========\n');

figure('Position', [50, 50, 1800, 900], 'Name', '非球面位姿求解结果');

% 子图1: 配准前
subplot(2,4,1);
plot3(Q_model(:,1), Q_model(:,2), Q_model(:,3), 'bo', 'MarkerSize', 8);
hold on;
plot3(P_measured(:,1), P_measured(:,2), P_measured(:,3), 'r^', 'MarkerSize', 8);
xlabel('X(mm)'); ylabel('Y(mm)'); zlabel('Z(mm)');
title('配准前'); legend('模型点Q', '测量点P');
grid on; axis equal; view(45,30);

% 子图2: N-G配准后
subplot(2,4,2);
Q_NG_trans = (R_NG*Q_model')' + p_NG';
plot3(Q_NG_trans(:,1), Q_NG_trans(:,2), Q_NG_trans(:,3), 'go', 'MarkerSize', 8);
hold on;
plot3(P_measured(:,1), P_measured(:,2), P_measured(:,3), 'r^', 'MarkerSize', 8);
for i=1:N_points
    plot3([Q_NG_trans(i,1), P_measured(i,1)], ...
          [Q_NG_trans(i,2), P_measured(i,2)], ...
          [Q_NG_trans(i,3), P_measured(i,3)], 'k--', 'LineWidth', 0.5);
end
xlabel('X(mm)'); ylabel('Y(mm)'); zlabel('Z(mm)');
title('N-G配准后'); legend('配准后Q', '测量点P');
grid on; axis equal; view(45,30);

% 子图3: LM配准后
subplot(2,4,3);
Q_LM_trans = (R_LM*Q_model')' + p_LM';
plot3(Q_LM_trans(:,1), Q_LM_trans(:,2), Q_LM_trans(:,3), 'mo', 'MarkerSize', 8);
hold on;
plot3(P_measured(:,1), P_measured(:,2), P_measured(:,3), 'r^', 'MarkerSize', 8);
for i=1:N_points
    plot3([Q_LM_trans(i,1), P_measured(i,1)], ...
          [Q_LM_trans(i,2), P_measured(i,2)], ...
          [Q_LM_trans(i,3), P_measured(i,3)], 'k--', 'LineWidth', 0.5);
end
xlabel('X(mm)'); ylabel('Y(mm)'); zlabel('Z(mm)');
title('LM配准后'); legend('配准后Q', '测量点P');
grid on; axis equal; view(45,30);

% 子图4: SVD配准后
subplot(2,4,4);
Q_SVD_trans = (R_SVD*Q_model')' + p_SVD';
plot3(Q_SVD_trans(:,1), Q_SVD_trans(:,2), Q_SVD_trans(:,3), 'co', 'MarkerSize', 8);
hold on;
plot3(P_measured(:,1), P_measured(:,2), P_measured(:,3), 'r^', 'MarkerSize', 8);
for i=1:N_points
    plot3([Q_SVD_trans(i,1), P_measured(i,1)], ...
          [Q_SVD_trans(i,2), P_measured(i,2)], ...
          [Q_SVD_trans(i,3), P_measured(i,3)], 'k--', 'LineWidth', 0.5);
end
xlabel('X(mm)'); ylabel('Y(mm)'); zlabel('Z(mm)');
title('SVD配准后'); legend('配准后Q', '测量点P');
grid on; axis equal; view(45,30);

% 子图5: N-G收敛曲线
subplot(2,4,5);
semilogy(1:length(history_NG.error), history_NG.error, 'b-o', 'LineWidth', 1.5);
xlabel('迭代次数'); ylabel('准则函数e(η)');
title('N-G收敛曲线'); grid on;

% 子图6: LM收敛曲线
subplot(2,4,6);
semilogy(1:length(history_LM.error), history_LM.error, 'r-s', 'LineWidth', 1.5);
xlabel('迭代次数'); ylabel('准则函数e(η)');
title('LM收敛曲线'); grid on;

% 子图7: LM阻尼因子
subplot(2,4,7);
semilogy(1:length(history_LM.lambda), history_LM.lambda, 'm-d', 'LineWidth', 1.5);
xlabel('迭代次数'); ylabel('阻尼因子λ');
title('LM自适应阻尼'); grid on;

% 子图8: 精度对比
subplot(2,4,8);
residuals_NG_norm = vecnorm(Q_NG_trans - P_measured, 2, 2);
residuals_LM_norm = vecnorm(Q_LM_trans - P_measured, 2, 2);
rmse_values = [
    sqrt(mean(residuals_NG_norm.^2))*1000;
    sqrt(mean(residuals_LM_norm.^2))*1000;
    rmse_SVD*1000
];
bar_h = bar(rmse_values, 'FaceColor', 'flat');
bar_h.CData(1,:) = [0 0 1];
bar_h.CData(2,:) = [1 0 0];
bar_h.CData(3,:) = [0 1 1];
set(gca, 'XTickLabel', {'N-G', 'LM', 'SVD'});
ylabel('RMSE (μm)');
title('算法精度对比'); grid on;
for i=1:3
    text(i, rmse_values(i)+0.5, sprintf('%.2f', rmse_values(i)), ...
         'HorizontalAlignment', 'center');
end

%% ========================================================================
%% 结果总结
%% ========================================================================
fprintf('\n========== 仿真结果总结 ==========\n');
fprintf('%-8s | 迭代 | α误差(°) | β误差(°) | p误差(mm) | RMSE(μm)\n', '算法');
fprintf('------------------------------------------------------------------\n');
fprintf('%-8s | %4d | %.6f | %.6f | %.6f | %7.2f\n', ...
    'N-G', length(history_NG.error), ...
    abs(alpha_k-alpha_true), abs(beta_k-beta_true), ...
    norm(p_k-p_true), rmse_values(1));
fprintf('%-8s | %4d | %.6f | %.6f | %.6f | %7.2f\n', ...
    'LM', length(history_LM.error), ...
    abs(alpha_lm-alpha_true), abs(beta_lm-beta_true), ...
    norm(p_lm-p_true), rmse_values(2));
fprintf('%-8s | %4s | %.6f | %.6f | %.6f | %7.2f\n', ...
    'SVD', '直接', ...
    abs(alpha_svd-alpha_true), abs(beta_svd-beta_true), ...
    norm(p_SVD-p_true), rmse_values(3));

fprintf('\n仿真完成!\n');

%% ========================================================================
%% 辅助函数
%% ========================================================================


function z = compute_aspherical_z(x, y, R, K, A4, A6)
    % 计算非球面Z坐标
    rho = sqrt(x^2 + y^2);
    c = 1 / R;
    discriminant = 1 - (1 + K) * c^2 * rho^2;
    
    if discriminant >= 0
        z = (c * rho^2) / (1 + sqrt(discriminant)) + A4 * rho^4 + A6 * rho^6;
    else
        z = NaN;
    end
end

function z_W = compute_measured_z(x_W, y_W, R_true, p_true, R, K, A4, A6)
    % 计算测头在(x_W,y_W)接触倾斜工件的Z坐标
    % 通过迭代求解满足非球面约束的接触点
    
    R_inv = R_true';
    z_W = p_true(3);  % 初始猜测:工件中心高度
    
    max_iter = 50;
    tol = 1e-8;
    
    for iter = 1:max_iter
        % 当前猜测下的机床系坐标
        p_W = [x_W; y_W; z_W];
        
        % 变换到工件坐标系
        p_M = R_inv * (p_W - p_true);
        x_M = p_M(1); 
        y_M = p_M(2); 
        z_M = p_M(3);
        
        % 计算非球面理论Z值
        z_M_theory = compute_aspherical_z(x_M, y_M, R, K, A4, A6);
        
        if isnan(z_M_theory)
            z_W = NaN;
            warning('点(%.1f,%.1f)超出非球面定义域', x_W, y_W);
            return;
        end
        
        % 残差:当前z_M与非球面约束的偏差
        residual = z_M - z_M_theory;
        
        % 收敛判断
        if abs(residual) < tol
            break;
        end
        
        % Newton迭代更新
        % Jacobian简化:∂residual/∂z_W ≈ R_inv(3,3)
        J = R_inv(3, 3);
        
        if abs(J) > 1e-10
            z_W = z_W - residual / J;
        else
            warning('Jacobian接近奇异,迭代终止');
            break;
        end
    end
    
    if iter == max_iter
        warning('compute_measured_z: 迭代未收敛 (x_W=%.1f, y_W=%.1f)', x_W, y_W);
    end
end

